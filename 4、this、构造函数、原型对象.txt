this

浏览器（解析器）在调用函数时，每次都会向函数传递一个隐含的参数。这个隐含参数就是this。
this指向函数执行的上下文对象。
根据函数的（调用）方式的不同，this指向不同的对象。和函数的创建方式无关。
1、以函数形式调用时，this就是window。此处实际就是window调用方法。
2、以方法形式调用，this就是这个对象。
3、当函数以构造函数方式使用时，this就是这个新创建的对象。
4、使用call(),apply()调用时，this是指定的对象。
5、在事件的响应函数中，this就是响应函数的绑定的那个元素。

***************************************
构造函数（类）

在创建时：习惯上名称的首字母大写，其他方面和普通函数没啥区别。

在调用时：普通函数直接 函数名（）调用，而构造函数需要使用 new 关键字调用。
var item = new 构造函数（）；

执行流程：
1、创建一个新的对象。
2、将新建的对象设置为构造函数中的this。在构造函数中，可以使用this引用新建的对象，这样就可以实现对新建对象的属性赋值。
3、执行构造函数中的代码。
4、把新对象作为返回值返回。构造函数中没有return。

//创建Person类的构造函数
function Person(name, age){
  this.name = name;
  this.age = age;
  this.sayName = function(){
    alert("这个人的名字是"+this.name);
  };
}
//创建一个Person类的对象
var p1 = new Person("小明", 18);

使用同一个构造函数创建的对象，称为一类。（构造函数名）类。Person类。
使用构造函数创建的对象，称为该类的实例。


instanceof 检查某对象是否是某类的实例
item instanceof class
对象 instanceof 构造函数名
属于返回true，不属于返回false；


所有对象都是Object类的实例。

//创建一个Person类的对象
var p1 = new Person("小明", 18);
var p2 = new Person("小华", 20);
显然p1和p2在创建时都各自创建了一个sayName函数

构造函数中的方法如果在构造函数内部定义，那么每创建一个新对象实例就会创建一次这个方法，（每个对象实例的这个方法”不“是同一个方法）。
构造函数中的方法应该在外部创建，在创建对象实例时，用这个方法对每个对象实例的方法进行赋值。这样每个对象实例的这个方法就是同一个方法。

在外部创建的方法需要使用this关键字实现对不同对象实例的区分。

但是
把函数定义在全局作用域中，污染了全局作用域的命名空间。
在联合开发项目中，函数可能因为重名而被覆盖，导致失效。

*********************************************************************
原型对象 prototype （父类？继承？静态成员变量？）

每创建一个函数，解析器都会向函数中添加一个属性 prototype，每个函数的prototype是特有的（唯一的）。

prototype对应的对象就是原型对象。

prototype保存的是原型对象的地址。

当函数作为构造函数使用时，他所创建的对象中都会包含一个prototype（每个对象实例的prototype和构造函数的prototype都一样），指向该构造函数的原型对象。
可以通过 __proto__访问这个属性。

原型对象相当于（这个类）的一个公共的区域，所有（这个类）的实例都可以访问到这个原型对象。

可以将对象实例中共有的内容，统一设置到原型对象中。
当访问对象实例的属性和方法时，先在实例自身中寻找，如果没找到，则到原型对象中寻找。

可以把对象实例共有的属性和方法统一放在原型对象中。
这样，可以保证这个属性或方法只被创建一次，且不会影响到全局作用域。

添加方式：
类名.prototype.属性名 = 赋值
类名.prototype.方法名 = function（）{}
使用this关键字访问。

//创建Person类的构造函数
function Person(name, age){
  this.name = name;
  this.age = age;
}
//在Person类的原型中添加sayName方法
Person.prototype.sayName = function(){
  alert("这个人的名字是"+this.name);
}
//创建一个Person类的对象
var p1 = new Person("小明", 18);
p1.sayName();
语句执行时，显然p1中没有sayName方法，所以到Person类的原型中找这个方法进行调用。

使用hasOwnProterty（）方法检查对象自身中是否含有某属性
使用in方法检查，原型中含时有也会返回true。

原型对象当然还有自己的原型对象

Object对象是所有对象的（根）原型，Object对象是最底层了，没有自己的原型。


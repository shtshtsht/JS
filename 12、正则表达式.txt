用途：用于定义一些字符串的规则。
计算机根据正则表达式计算输入的字符串是否合法。也可将字符串中复合规则的内容提取出来。

1、创建
正则表达式对象
var reg = new RegExp（“正则表达式”，“匹配模式”）；
var reg = /正则表达式/匹配模式；注意这里不是字符串

2、test（）
检测字符串是否符合正则表达式。
reg.test(str)；用reg检查字符串str。
复合返回true。不符合则返回false。

3、匹配模式
可缺省，默认区分大小写。
i：忽略大小写
g：全局匹配模式
ig或gi：既忽略大小写，又搜索全局。

4、正则表达式
/abc/；检查字符串中是否含有abc；
/a|b|c/；检查是否含有a或b或c；
/[abc]/；同上，a或b或c

/[a-z]/；检查任意小写
/[A-Z]/；任意大写
/[A-z]/；任意字母
/[0-9]/；任意数字

/abc|adc|aec/；
/a[bde]c/；相当于三组或

[^]：表示 除了 xxx
/[^ab]/；找除了a，b以外的字母

*********************************************
String中支持正则表达式的方法

1、split（）
根据任意字母拆分字符串
默认全局匹配
split（/[A-z]/）

2、search（）
普通用法时，和indexOf（）相同；
【不】支持全局匹配，只会查找第一个。
可接收正则表达式作为参数
search（/a[ef]c/）;检索是否含有aec或afc

3、match（）
提取符合条件的内容。
返回值为数组类型。

默认情况下，找到第一个复合要求的内容即返回。
match（/[A-z]/）；提取第一个搜索到的字母。

需要设置全局匹配模式
match（/[A-z]/g）；提取到所有字母。

4、replace（“oldStr”，“newStr”）
不会影响原串
把 oldStr 替换为 newStr。
oldStr可以是正则表达式

默认只替换第一个，加g进行全局匹配模式。
使用空串作为 newStr，实现删减。


*******************************************************
量词

1、{n}或{n,m}
量词，只作用与前面相邻的一个元素

设置单个元素连续出现n次。
/a{3}/；a连续出现3次。即aaa

设置一组元素连续出现n次
/（ab）{3}/；ab连续出现3次。即ababab

设置元素出现n到m次
/a{1,4}/；a出现1到4次。

m缺省，出现n次以上
/a{2, }/； a出现2次以上

2、+ * ？
+至少1个，相当于{1，}
/a+/；至少一个a

*至少0个，相当于{0，}
/a*/；有没有都行。

？至多1个，相当于{0，1}
/a?/；一个a或者没有a

3、^ $
/^a/；匹配开头，看是否以a开头
/a$/；匹配结尾，看是否以a结尾
/^a|a$/；以a开头或者以a结尾
/^a$/；必须就是a

^$同时使用，则要求被检测串完全符合正则表达式。
不用起止符，则被测串中含有符合正则表达式的元素就行。

********************************************************
元字符

\ 依然是转义字符
/\./；以 . 作为正则表达式

注意使用构造函数时，参数是字符串，\在串中也是转义字符，所以需要多打一个\ 。

reg = / \\ /；等效于 RegExp（"\\\\"）;

单词边界
\b 和 \B
\b 单词前后都是空格，即单词是独立的单词
用于去除空格


*********************************
手机号正则表达式：/^1[3-9][0-9]{9}$/

邮箱地址正则表达式：/^\w{3,}(\.\w+)*@[A-z0-9]+(\.[A-z]{2,5}){1,2}$/

